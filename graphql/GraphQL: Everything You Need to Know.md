# 你应该知道的GraphQL


[原文] ([GraphQL: Everything You Need to Know – Weblab Technology – Medium](https://medium.com/@weblab_tech/graphql-everything-you-need-to-know-58756ff253d8))

你应该构建和使用REST API已经有一段时间了，并且不久前也听过关于GraphQL——在API技术领域一种新的宣传。有人说它很不错，有人却不这么认为。好的，我想你们都想知道这个GraphQL与传统的方法有什么不同。

这篇文章的主要目的是强调与GraphQL相关的主要特性，并讨论与此特定API规范相关的重要优点和缺点。

GraphQL通常被描述为前端导向的API技术，因为它允许前端开发人员比以前更方便的请求数据。据Facebook介绍，这种查询语言的目标是制定以本能和可调格式形成的客户端应用程序，用于描述他们数据的先决条件以及相互作用。最好的部分是语言不依赖于任何特定的数据库管理系统，并且受到你当前的数据以及编码的支持。

传统的REST的基本问题之一是没法要求个性化的数据集。除此之外，运行和控制多个断电是另一个难点，因为客户端通常需要从不同的端点请求数据。

当建立了GraphQL服务器，完成数据采集和更改最重要的是需要一个URL。
因此用户可以通过向服务器传递查询字符串，提到他们所需的内容来请求数据集。

## GraphQL vs REST
当提到相似之处，REST和GraphQL都可以用于构建API。另外，他们都能基于HTTP运行。

就差异而言，REST主要是以网络为中心软件的结构概念，没有明确规范，也没有明确的工具集。它更专注与API的耐久性而非性能优化。

另一方面，GraphQL是一种设计通过HTTP在一个端点上工作来提升性能和适应性的查询语言。我甚至会说比较两种查询语言以及用于开发web服务的架构风格看起来会有点奇怪:)。其他一些显著的差异包括：

### 数据提取
数据提取无疑是GraphQL最引人注目的进步之一。在标准的REST API中，为了产生和修复数据，我们可能需要向多个端点请求数据。相比之下，在GraphQl中只需要单个端点，我们就可以获取服务器上可用的数据。
```
query {
  books {
    id
    title
    author
    isbn
    price
  }
}
```

### Over or Under Data Fetching
由于REST规范中每个端点包含固定的数据生成，因此在REST中比GraphQL更容易获取更多的数据。同样的，使用REST获取数据集相对来说比较容易，使客户端能够发起额外的请求获取相关数据。

这种情况对于GraphQL来说就大不相同了。由于它是一个支持声明式数据提取的查询语言，用户只能从服务器获取他们实际需要的内容。

#### 只选择书的标题和价格

```
query {
  books {
    title
    price
  }
}
```

### 错误管理
REST规范中的错误管理十分简单。我们只需要检查HTTP头部报文来了解响应的位置。根据状态码，我们能够快速声明错误以及解决问题的合适的方法。另一方面，在GraphQL状态下，我们总是接收到200 OK的状态码

```
Request: query { books { error_field } }
Response:
Request Method:POST
Status Code: 200 OK
{“errors”:[{“message”:”Cannot query field \”error_field\” on type \”Book\”.”,”category”:”graphql”,”locations”:[{“line”:3,”column”:3}]}]}
```

### 高速缓存
由于REST是通过HTTP被强制执行使缓存生效，你可以用它来避免资源的获取。另一方面，GraphQL没有缓存系统，因此让用户自己承担了处理缓存的负担。

## GraphQL —— 优点
### 版本控制
当控制从一个API边缘收回受限的数据时，任意转换都被看作是突破性的变化，并且需要更新版本来进行重大更改。这或许是大多数API选择版本控制的最大原因。如果API要包含更新的特征就需要最新的版本，就会在发布的对API的解释和保留之间出现调整。

相比之下，GraphQL只反弹了所需的数据，因此最新的设备可以通过最新的类型和字段来包含这些数据，而不用出发重大更改。

### 轻松弃用
使用GraphQL，你可以很方便的放弃某个字段。GraphQL用户一定在查询中提到他们需要的字段。

```
‘author_name’ => [
  ‘type’ => Type::string(),
  ‘deprecationReason’ => ‘Deprecated. Use author field’,
 ],
```

REST API以不同的方式运行。虽然基本的端点可以在所有的REST API中访问，但是不是所有的都能获取稀有的字段集。

相比之下，GraphQL使监控特定字段的使用变得极其轻松。API使用者可以让特定的客户端使用它们提供的字段。

### 性能优化
虽然REST通常默认请求的是整体，GraphQL一般请求最少最合适的数据。尽管REST API也可以返回基本的部分，但是也有更多的片段需要默认通过GraphQL传递。

## GraphQL — 缺点
### 使用GraphQL缓存不容易
REST利用了HTTP存储的约定使当前的客户端和代理完美工作以帮助服务端和客户端，不同的是GraphQL完全采用不同的处理方法。当然，事情并不像REST那么容易，你必须重新整理你的数据集，使用了一个Redis集合并且总是需要起到你的客户端也能够缓存。

[graphql.org](http://graphql.org/learn/caching/)作出了清晰地解释，

> ”*在基于端点的API中，客户端能够使用HTTP缓存轻松避免了重复获取资源，并且能够识别两个相同的资源。这些API中的URL是一个客户端用来构建缓存的全局唯一标识符。但是在GraphQL中，没有类似的原始URL为给定的对象提供全局唯一标识符。因此API的最佳实践是公开此类标识符供客户端使用。*“

### 授权问题
授权问题也是我们在使用GraphQL时需要注意的一个问题。考虑到GraphQL作为一个领域的特定语言。它也仅仅是我们放置在数据服务和我们的客户端之间的单独的一层。授权完全是一个独立的层，语言本身并不能帮助应用或者使用的认证或者验证。但是，你可以使用GraphQL将客户端和计划的入口令牌有效的联系起来。这与我们在REST中遵循的方法比较相似。

## 检查和解决n+1问题
### 什么是n+1问题？
n+1问题是在起草GraphQL后端时可能面临的最明显的优化问题。

如果你没有优化你的GraphQL查询，你最终可能会在仅有一个查询的情况下发送多次往返。没有一个合适的高速缓存或者批处理系统，每次查询字段时，一个简单的服务都会轻松的发出新的数据请求。DataLoader无疑是最好的解决方案，它能够极大增加后端的性能，特别是对GraphQL服务器来说。

用一个简单的例子来展现n+1问题：

```
query {
  users {
    name
    education {
      degree
      year
    }
    age
    address {
      country
      city
      street
    }
  }
}
```

使用REST APIS能够很容易的评估，辨认和解决N+1问题。尽管这个问题和GraphQL不同，但幸运的是，Facebook正在为这个问题开发一个可行的解决方案——Dataloader。

### 什么是Dataloader？
DataLoader是一个实用工具，用户可以用来读取数据并且可以访问GraphQL函数。我们可以直接用这个工具从记录中获取数据而不用依赖SQL查询。

#### 它如何工作？
DataLoader主要利用批处理和缓存的混合。它能够被用来批量加载来自客户端询问的多个问题/请求的答案。另外，它还可以缓存应答，以便在有连续的类似资源查询时轻松获取缓存中的数据。

#### GraphQL中的查询，突变以及订阅
好的，我们已经强调了关于GraphQL的重点部分。但是，要开发一个功能完全的应用程序，我们还需要一些能用于增强你工作中功能性和优化型的因素。
#### 查询
顾名思义，查询就是客户端从服务器发起的数据请求。REST中多个端点有明显重复的数据结构，与之不同的是GraphQL只公开一个端点，就能使客户端从预定义的框架中确定实际需要的信息。
例如：
```
{
  Users {
    name
  }
}
```

上面提到的查询字段中的‘Users’字段被称为根字段，后面的任何数据都被称为有效载荷。

该查询将生成所有用户的名称列表。

```

{
  "Users": [
    {"name": "Damira"},
    {"name": "Michael"}
    {"name": "Salman"}
    {"name": "Sara"}
    {"name": "Maria"}
  ]
}
```

这个生成用户名称的查询值得注意一下（因为在我们的查询中，我们明确制定了我们只需要名称列表）。对于任何额外的请求，我们都需要为他添加具体的细节。

例如，假设我们希望获取列表最后3名用户的信息。我们现在可以利用参数来实现。
```
{
  Users(last: 3) {
    name
    username
  }
}
```

因此，我们观察到如何利用查询从服务器获取数据。现在我们来看看在GraphQL中创建，省略以及更新数据的方法。

#### 突变
mutation被用于创建、更新和删除数据。它的结构和查询类似，只是你需要在开始出添加”mutation“。例如：

```
mutation {
  createUser(name: 'John', username: 'jo123') {
    name
    username
  }
}
```

#### 订阅
订阅能够被用于设置和保留与服务器的实时连接。它允许你获取有关事件的即时信息。大多数时候，客户端需要订阅特定事件以获取有关数据。

请前往[http://graphql.org/learn/queries/]( http://graphql.org/learn/queries/)以获取更多细节。

## 两全其美，各取其长
尽管GraphQL能解决不少问题，它依旧有缺点和瑕疵。例如验证、策略或缓存等等。由于它本质上不具有说服力，没有指导用户如何应用这些层。除此之外，后端服务器和你的客户端之间存在这种不具有具体概念的层会令人不安。

一些基本问题可以查看Apollo Stack提供的[指南](https://dev-blog.apollodata.com/a-guide-to-authentication-in-graphql-e002a4039d1)找出答案。

如果你有一个正在运行的项目，想要从原始的REST API快速转移到GraphQL方法是很困难的。但是，好消息是你可以同时使用这些API技术来各取其长。

例如，你可以使用GraphQL查询开始重构你的前端数据获取，然后开始整合突变行为。这可以允许你缓慢的减少你的控制器行为。

此外，还可以让这些方法在你的项目里长期同时工作。例如，如果你想简化授权机制，你可以总是从REST框架获取帮助。

## 结论
回忆一下，在90年代后期，SOAP被夸张宣传，获得了极大支持作为在计算机网络中web服务的应用交换结构信息的强大协议规范。然而，明显偏高的有效载荷和之前应用程序的碎片化引起了迷失障碍。

REST被介绍是为了响应对发布和利用web服务更实际和更适应性的方法。这个概念简单明了，完全无状态，因此抛开了任何不相关的难题。另外，这种方法还可以轻松与JSON和XML结合。但是，数据的统一是最大的障碍。版本管理也是另一个问题。为了解决这些问题，Facebook为开发人员提供了一个两全其美的解决办法——GraphQL。

GraphQL不是没有具体和实践基础的解释的唯一解决方案。多年来RESTful API已经被证实具有效率和性能。GraphQL掩盖了REST的缺失，而REST填补了GraphQL中存在的空白。

很明显，GraphQL和REST的情况就与关系数据库和非关系数据库的情况一样。

当使用GraphQL时，主要HTTP是最普遍的，无疑是客户端-服务器协议的最优选择。然而，当服务涉及到HTTP2时还存在有一定的性能问题。

虽然GraphQL已经解决了我们遇到的一些问题，但在某些时候你依旧会对选择那个API规范感到困惑，因为这种时候你应该同时选择使用。

从设计和应用到定价和整合应用，选择一个API框架将对整个API进程产生影响。因此，这种选择要有一定的经验而不能仅仅依赖简单的信仰。

这篇文章完全基于我们对这两种方法的个人使用经验。我们希望听到您对GraphQL和RESTful API的意见或评论。